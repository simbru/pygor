
import numpy as np
import skimage.filters
import matplotlib.pyplot as plt
import matplotlib as mpl
import warnings
import scipy
global_thresh_val = 3
min_targets =     0
min_hole_size =   0
min_object_size = 2

def _detect_targets(spatial_filter, thresh_value = global_thresh_val, min_targets = min_targets,result_plot = False, **kwargs):
    """
    Detect targets based on the spatial filter values and return the indices of the detected targets.
    In short, the algorithm detects targets over the given threshold value on the first pass. On the 
    second pass, the algorithm detects targets over the median of the detected targets on the first pass
    (to prune out noise).

    Parameters:
         spatial_filter : np.array
             The spatial filter values to analyze.
         thresh_value : float, optional
             The threshold value for target detection (default is 2.5).
         result_plot : bool, optional
             A flag to indicate if a plot of the detected targets should be displayed (default is False).
         **kwargs
             Additional keyword arguments for customization.

    Returns:
         detected_targets : list
             A list of indices corresponding to the detected targets.
    """
    if isinstance(spatial_filter, np.ma.core.MaskedArray):
        spatial_filter = spatial_filter.data
     # Detect targets
    spatial_filter_abs_flat = np.abs(spatial_filter).flatten()
    detected_targets_firstpass = np.where(spatial_filter_abs_flat > thresh_value)[0]
    if len(detected_targets_firstpass) == 0: 
        detected_targets = []
    else:
        level_set_abs = np.median(spatial_filter_abs_flat[detected_targets_firstpass])
        detected_targets = np.where(spatial_filter_abs_flat > level_set_abs)[0]
    if result_plot:
        if kwargs.get("ax") is None:
            fig, ax = plt.subplots(1,1, figsize = (5, 3))
        else:
            ax = kwargs.get("ax")
        ax.plot(np.abs(spatial_filter).flatten())
        ax.plot(spatial_filter_abs_flat)
        ax.scatter(detected_targets_firstpass, spatial_filter_abs_flat[detected_targets_firstpass], c="r", label = "first pass", marker = 7)
        ax.scatter(detected_targets, spatial_filter_abs_flat[detected_targets], c="g", label = "second pass")
        # ax.legend()
        ax.set_title("Thresholded values")
    if len(detected_targets) < min_targets:
        detected_targets = []
    return detected_targets

def _gen_filter_mask(spatial_filter, thresh_value = global_thresh_val, min_hole_size = min_hole_size, min_object_size = min_object_size, result_plot = False, **kwargs):
    """
    Generate a binary mask based on spatial filtering of detected targets. This is the third pass 
    of the target detection algorithm. In short, the algorithm removes small holes and objects
    before dilating the binary mask. The logic here is to include proximal pixels close to the 
    initial mask generated by _detect_targets, which only considers raw values. In other words,
    this step considers the spatial component of the data.
    
    If `result_plot` is True, it plots the original signal, the masked signal, and the binary mask.
    
    Parameters
    ----------
    spatial_filter : array_like
        The spatial data to filter.
    thresh_value : float, optional
        The threshold value for target detection. Default is 2.5.
    min_hole_size : int, optional
        Remove contiguous holes smaller than the specified size.. Default is 2.
    min_object_size : int, optional
        The minimum object size in the binary mask that will not be removed. Default is 3.
    result_plot : bool, optional
        If True, the function will plot the results. Default is False.
    **kwargs : dict, optional
        Additional keyword arguments.
        
    Returns
    -------
    mask : ndarray
        The processed binary mask after detecting targets, removing small holes and objects, and dilation.
    """
    # Keep track of input shape (for reshaping)
    shape = spatial_filter.data.shape
    targets = _detect_targets(spatial_filter, thresh_value = thresh_value)
    # Mask processing
    mask = np.zeros(len(spatial_filter.flatten()))
    mask[targets] = 1
    mask = mask.astype(bool).reshape(shape)
    mask = skimage.morphology.remove_small_objects(mask, min_size = min_object_size)
    mask = skimage.morphology.remove_small_holes(mask, area_threshold = min_hole_size)
    # Double dialation is intentional
    mask = skimage.morphology.binary_dilation(mask)
    # mask = skimage.morphology.binary_dilation(mask)
    if result_plot:
        if kwargs.get("color") is not None: 
            kwargs["c"] = kwargs["color"]
        if kwargs.get("c") is None:
            kwargs["c"] = "yellow"
        # Apply mask to signal and output 
        spatial_filter_output = np.copy(spatial_filter.flatten())
        spatial_filter_output[~mask.flatten()] = 0
        spatial_filter_output = spatial_filter_output.reshape(shape)
        if kwargs.get("ax") is None:
            fig, ax = plt.subplots(1, 3, figsize = (20, 4))
        else:
            ax = kwargs.get("ax")
        non_zero_spatial_filter = spatial_filter.flatten()[spatial_filter.flatten()!=~0]
        post_processing_tarets = np.where(mask.flatten() == 1)[0]
        ax[0].plot(non_zero_spatial_filter, c="orange")
        ax[0].scatter(post_processing_tarets, non_zero_spatial_filter[post_processing_tarets], c=kwargs["c"], 
            label = "third pass")
        # ax[0].legend()
        ax[1].imshow(spatial_filter, origin = "lower")
        # ax[2].imshow(mask)
    return mask

def _fit_filter_contour(spatial_filter_mask, gauss_sigma = 1, result_plot = False, **kwargs):
    """
    This function applies a Gaussian filter to the input binary mask to smooth 
    it. Then, it finds the contours of the smoothed mask. Optionally, it can 
    plot the contours over the mask for visualization purposes.

    Parameters
    ----------
    spatial_filter_mask : ndarray
        Binary mask to which the Gaussian filter is applied.
    gauss_sigma : float, optional
        The sigma (standard deviation) of the Gaussian filter, by default 1.
    result_plot : bool, optional
        If True, the function will plot the contours over the mask, by default False.
    **kwargs : dict
        Additional keyword arguments for plotting, such as 'color', 'ax', etc.

    Returns
    -------
    list of ndarray
        A list containing the coordinates of the contours of the filtered mask.
    """
    spatial_filter_mask = skimage.filters.gaussian(spatial_filter_mask, sigma = gauss_sigma, mode = "nearest")
    contour = skimage.measure.find_contours(spatial_filter_mask)
    if result_plot:
        if kwargs.get("color") is not None: 
            kwargs["c"] = kwargs["color"]
        if kwargs.get("c") is None:
            kwargs["c"] = "red"
        if kwargs.get("ax") is None:
            fig, ax = plt.subplots(1, 1, figsize = (10, 5))
            ax
            ax.imshow(spatial_filter_mask, origin = "lower")
            for contour_n in contour:
                ax.plot(contour_n[:, 1], contour_n[:, 0], lw = 3, ls = '-',alpha = .8, c = kwargs["c"])
            plt.show()
        else:
            ax = kwargs.get("ax")
            for a in ax[:1]:
                for contour_n in contour:
                    a.plot(contour_n[:, 1], contour_n[:, 0], lw = 3, ls = '-',alpha = .8, c = kwargs["c"])
    return contour    

def bipolar_mask(spatial_filter, abs_thresh_val = global_thresh_val, plot_results = False, ax = None):
    if np.ma.isMaskedArray(spatial_filter):
        spatial_filter = spatial_filter.data
    neg_filter = np.clip(spatial_filter, None, 0)
    pos_filter = np.clip(spatial_filter, 0, None)
    neg_mask = _gen_filter_mask(neg_filter, thresh_value=abs_thresh_val)
    pos_mask = _gen_filter_mask(pos_filter, thresh_value=abs_thresh_val)
    # Then, segment the masks into its constituent parts
    neg_mask_labeled = skimage.measure.label(neg_mask)
    pos_mask_labeled = skimage.measure.label(pos_mask)
    # Loop logic: Sort the labelled mask into positive and negative masks, then combine separately
    neg_unique_labels = np.unique(neg_mask_labeled) # unique_labels[unique_labels > 0]
    pos_unique_labels = np.unique(pos_mask_labeled)
    neg_unique_labels = neg_unique_labels[neg_unique_labels > 0] 
    pos_unique_labels = pos_unique_labels[pos_unique_labels > 0] 
    # Loop through the unique labels and append the masks accordingly
    neg_mask = []
    pos_mask = []
    for n, label in enumerate(neg_unique_labels):
        # Get the average value within the labelled region of the mask
        current_mask_vals = neg_filter[neg_mask_labeled == label]
        label_average = np.average(current_mask_vals)
        # Append the mask accordingly
        if label_average < 0:
            neg_mask.append(np.where(neg_mask_labeled == label, 1, 0))
        else:
            raise ValueError("Negative mask contains a region with positive average value. This is not allowed.")
    for n, label in enumerate(pos_unique_labels):
        # Get the average value within the labelled region of the mask
        current_mask_vals = pos_filter[pos_mask_labeled == label]
        label_average = np.average(current_mask_vals)
        # Append the mask accordingly
        if label_average > 0:
            pos_mask.append(np.where(pos_mask_labeled == label, 1, 0))
        else:
            raise ValueError("Positive mask contains a region with negative average value. This is not allowed.")
    # Check if masks conflict
    # plt.close('all')
    # plt.imshow(pos_mask[0])
    # Sum to combine the masks according to polarity
    if neg_mask == []:
        neg_mask = np.ones(spatial_filter.shape).astype(bool)
    else:
        neg_mask = np.invert(np.sum(np.array(neg_mask), axis = 0).astype(bool))
    if pos_mask == []:
        pos_mask = np.ones(spatial_filter.shape).astype(bool)
    else:
        pos_mask = np.invert(np.sum(np.array(pos_mask), axis = 0).astype(bool))
    if np.all(neg_mask == 1) and 0 in pos_mask:
        neg_mask = np.invert(pos_mask.astype(bool))
    if 0 in neg_mask and np.all(pos_mask == 1):
        pos_mask = np.invert(neg_mask.astype(bool))    
    # # Throw error if overlap exists
    # if np.any(neg_mask > 1) or np.any(pos_mask > 1):
    #     raise ValueError("Masking logic insufficient, leading to overlapping masks. Manual fix required.")
    # Check if masks conflict (prioritise bigger mask)
    neg_mask_indices = np.argwhere(neg_mask == 0)
    pos_mask_indices = np.argwhere(pos_mask == 0)
    if len(neg_mask_indices) > len(pos_mask_indices):
        matching_indices = np.array((pos_mask_indices[:,None] == neg_mask_indices).all(2).any(1))
        prune_indices = pos_mask_indices[matching_indices]
        pos_mask[prune_indices[:, 0], prune_indices[:, 1]] = 1
    else:
        matching_indices = np.array((neg_mask_indices[:,None] == pos_mask_indices).all(2).any(1))
        prune_indices = neg_mask_indices[matching_indices]
        neg_mask[prune_indices[:, 0], prune_indices[:, 1]] = 1
    if plot_results:
        ax[0].imshow(neg_mask, origin = "lower")
        ax[1].imshow(pos_mask, origin = "lower")
        # final_neg = np.argwhere(neg_mask.flatten() == 0)
        # final_pos = np.argwhere(pos_mask.flatten() == 0)
        # ax[0, 1].scatter(final_neg, neg_filter.flatten()[final_neg], c = 'cyan', label = 'final', marker = 'o')
        # ax[0, 1].legend()
        # ax[1, 1].scatter(final_pos, pos_filter.flatten()[final_pos], c = 'cyan', label = 'final', marker = 'o')
        # ax[1, 1].legend()
    return neg_mask, pos_mask

def bipolar_contour(spatial_filter, abs_thresh_val = global_thresh_val, plot_results = False, ax = None, **kwargs):
    """
    Processes a spatial filter mask to segment and contour areas based on polarity.

    This function takes a spatial filter mask, segments it into its constituent parts,
    and identifies contours of areas with positive and negative average values within
    the labeled regions. If `plot_results` is set to True, it also plots the segmentation
    and contouring results. The function returns separate contours for positive and negative
    regions.

    Parameters
    ----------
    spatial_filter : array_like
        The spatial filter mask to be processed.
    plot_results : bool, optional
        Flag to indicate whether to plot the segmentation and contour results.
    **kwargs : dict
        Additional keyword arguments passed to contour fitting function.

    Returns
    -------
    tuple of (array_like, array_like)
        A tuple containing two elements; the first for negative contours, and
        the second for positive contours.

    Raises
    ------
    ValueError
        If the masking logic is insufficient and leads to overlapping masks.
    """
    # Split arrays
    neg_filter = np.clip(spatial_filter, None, 0)
    pos_filter = np.clip(spatial_filter, 0, None)
    # Determine if there are targets
    _neg_targets = _detect_targets(neg_filter, thresh_value = abs_thresh_val)
    _pos_targets = _detect_targets(pos_filter, thresh_value = abs_thresh_val)
    # Threshold targets 
    if len(_neg_targets) < min_targets:
        _neg_targets = []
    if len(_pos_targets) < min_targets:
        _pos_targets = []
    # Plot that process, conditionally
    if plot_results is True:
        neg_filter = np.clip(spatial_filter, None, 0)
        pos_filter = np.clip(spatial_filter, 0, None)
        if ax is None:
            fig, ax = plt.subplots(2, 4, figsize = (10*1.5, 3*1.5))
            offset = 1
        else:
            fig = plt.gcf()
            offset = 0
        _neg_targets = _detect_targets(neg_filter, thresh_value = abs_thresh_val, result_plot=1, ax = ax[0, 1 - offset])
        _pos_targets = _detect_targets(pos_filter, thresh_value = abs_thresh_val, result_plot=1, ax = ax[1, 1 - offset])
        neg_mask = _gen_filter_mask(neg_filter, thresh_value=abs_thresh_val, result_plot=1, ax = ax[0, 2 - offset:].flatten(), c = "yellow")
        pos_mask = _gen_filter_mask(pos_filter, thresh_value=abs_thresh_val, result_plot=1, ax = ax[1, 2 - offset:].flatten(), c = "yellow")
        neg_mask, pos_mask = bipolar_mask(spatial_filter, plot_results=plot_results, ax = ax[:,  4 - offset])
        ax[0, 2 - offset].scatter(_neg_targets, neg_filter.flatten()[_neg_targets], c = 'cyan', label = 'final', marker = 5)
        ax[1, 2 - offset].scatter(_pos_targets, pos_filter.flatten()[_pos_targets], c = 'cyan', label = 'final', marker = 5)
        # Combine all legends
        lines_labels = [ax.get_legend_handles_labels() for ax in fig.axes[:4]]
        lines, labels = [sum(lol, []) for lol in zip(*lines_labels)]
        fig.legend(lines, labels, loc = 'lower left', ncol = 4, bbox_to_anchor = (.175, -.075))

   # Get masks
    neg_mask, pos_mask = bipolar_mask(spatial_filter)
    # Determine which mask is the inverted one
    is_inverse = np.all(np.invert(neg_mask) == pos_mask)
    skip_mask = 0
    if is_inverse:
        # Determine which mask is the inverted one
        pos_mask_sum = np.sum(pos_mask)
        neg_mask_sum = np.sum(neg_mask)
        # Assign value to skip that mask
        if neg_mask_sum > pos_mask_sum:
            skip_mask = -1
        if pos_mask_sum > neg_mask_sum:
            skip_mask = 1
    # Contour seperately based on polarity and skip mask
    # Here we plot
    if plot_results is True:
        if isinstance(_neg_targets, list) and _neg_targets == [] or skip_mask == 1: 
            neg_contours = []
        else:
            neg_contours = _fit_filter_contour(neg_mask, result_plot = 1, ax = ax[0, 3 - offset:], c = "blue", **kwargs)
        if isinstance(_pos_targets, list) and _pos_targets == [] or skip_mask == -1:
            pos_contours = []
        else:
            pos_contours = _fit_filter_contour(pos_mask, result_plot = 1, ax = ax[1, 3 - offset:], c = "red", **kwargs)
        plt.tight_layout()
    # Here we don't plot
    else:
        if isinstance(_neg_targets, list) and _neg_targets == [] or skip_mask == 1:
            neg_contours = []
        else:
            neg_contours = _fit_filter_contour(neg_mask)
        if isinstance(_pos_targets, list) and _pos_targets == [] or skip_mask == -1:
            pos_contours = []
        else:
            pos_contours = _fit_filter_contour(pos_mask)
    return (neg_contours, pos_contours)

""""Contour metrics"""

def contour_centroid(contours):
    """
    Calculates the centroid of each contour in a given list of contours.

    Args:
        contours (list): A list of contours. Each contour is a numpy array of (x,y) coordinates.

    Returns:
        numpy.ndarray: An array of shape (n,2) where n is the number of contours in the input list.
        Each row of the array contains the (x,y) coordinates of the centroid of the corresponding contour.
    """
    centroids_array = np.empty((len(contours), 2))
    for n, contour in enumerate(contours):
        # centroids_array[n] = contour
        centroid = np.average(contour, 0)
        centroids_array[n] = centroid
    return centroids_array

def contours_area(list_of_contour_lists, scaling_factor = 1):
    """
    Computes the area for each list of contours in a given list of lists of contours.
    
    Parameters:
    -----------
    list_of_contour_lists : list of lists of numpy arrays
        A list of lists, where each inner list contains numpy arrays that represent a contour. 
        The contours can have different numbers of points and dimensions, but they should all be of the same dtype.
    
    Returns:
    --------
    areas_array : numpy array
        An array of the same length as the input list_of_contour_lists, containing the area for each list of contours.
        The area is computed as the sum of the areas of all the contours in the list, using the cv2.contourArea function.
        The areas are rounded to two decimal places.
    """
    # Pre-allocate memory for storing area values
    areas_array = np.zeros(len(list_of_contour_lists))
    # Loop through each list in the list of lists
    for n, contour_list in enumerate(list_of_contour_lists):
        # Copmute area for each list of contours and store it
        areas_array[n] = np.round(PolyArea(contour_list, scaling_factor = scaling_factor), 3)
    if areas_array.size == 0: # if no contour
        return np.array([0])
    else: # normally
        return areas_array

def contours_area_bipolar(tuple_of_contours_list, scaling_factor = 1):
    """
    Computes the area of contours for two sets of contour lists: negative and positive.
    
    Args:
    - tuple_of_contours_list (tuple): a tuple of two lists, each containing contour lists
    
    Returns:
    - neg_areas (numpy.ndarray): an array containing the area values for the negative contours
    - pos_areas (numpy.ndarray): an array containing the area values for the positive contours
    """
    neg_areas = contours_area(tuple_of_contours_list[0], scaling_factor = scaling_factor)
    pos_areas = contours_area(tuple_of_contours_list[1], scaling_factor = scaling_factor)
    return neg_areas, pos_areas


def _extend_2darray(arr_2d):
    """arr_2d is 2d list of points"""
    return np.append(arr_2d[:-1], arr_2d[:3,], axis = 0)

def rotation_direction(coordinates):
    """
    Determine the rotation direction of a sequence of 2D coordinates.
    
    Args:
        coordinates (numpy.ndarray): An array of shape (n, 2) representing the 2D coordinates.
        
    Returns:
        int: -1, 1, or 0. -1 is counterclockwise. 1 is clockwise. 0 is no rotation. 
    """
    # Ensure we have at least 3 coordinates for meaningful rotation analysis
    if len(coordinates) < 3:
        raise ValueError("At least 3 coordinates are required")
    coordinates = np.array(coordinates)
    # Compute the vectors between consecutive points
    v1 = coordinates[1:] - coordinates[:-1]
    # Roll the vectors to align them with the next points
    v2 = np.roll(v1, -1, axis=0)
    # Compute the cross products for all pairs of vectors
    cross_products = np.cross(v1, v2)
    # Calculate the total cross product
    total_cross_product = np.sum(cross_products)
    # Return
    if total_cross_product > 0:
        # Counterclockwise
        return -1
    elif total_cross_product < 0:
        # Clockwise
        return 1
    else:
        # No rotation
        return 0

def calculate_interior_angles(vertices):
    vertices = vertices[1:].astype("float") #otherwise can yield type-mismatch bug
    shifted_vertices = np.roll(vertices, shift=1, axis=0)
    angle_vectors1 = shifted_vertices - vertices
    angle_vectors2 = np.roll(vertices, shift=-1, axis=0) - vertices
    
    cross_product_mag = angle_vectors1[:, 0] * angle_vectors2[:, 1] - angle_vectors1[:, 1] * angle_vectors2[:, 0]
    dot_product = angle_vectors1[:, 0] * angle_vectors2[:, 0] + angle_vectors1[:, 1] * angle_vectors2[:, 1]
    
    angles_radians = np.arctan2(cross_product_mag, dot_product)
    negative_angles = angles_radians < 0
    angles_radians[negative_angles] += 2 * np.pi
    
    return angles_radians

def get_vertex_points(arr_2d):
    """arr_2d is 2d list of points"""
    extended_arr = _extend_2darray(arr_2d)
    return np.array([extended_arr[n:n+3] for n, vertex in enumerate(extended_arr)][:-3])

# def calc_vertex_angles(arr_2d):
#     _vertex_points = get_vertex_points(arr_2d)
#     return np.array([calculate_interior_angle(i[0], i[1], i[2]) for i in _vertex_points])    

def calc_notches_norm(arr_2d):
    return contour_metrics(arr_2d)[-1]

def get_convex_hull(arr_2d):
    """
    Cite:   Barber, C.B., Dobkin, D.P., and Huhdanpaa, H.T., "The Quickhull 
        algorithm for convex hulls," ACM Trans. on Mathematical Software,
        22(4):469-483, Dec 1996, http://www.qhull.org.
    """
    rotation_input_array = rotation_direction(arr_2d)
    _hull = scipy.spatial.ConvexHull(arr_2d) #QHull
    _convex_hull = arr_2d[_hull.vertices]
    _convex_hull = np.append(_convex_hull, np.expand_dims(_convex_hull[0], axis = 0), axis = 0)
    rotation_output_array = rotation_direction(_convex_hull)
    if rotation_input_array != rotation_output_array:
        return np.flip(_convex_hull, axis = 0)
    return _convex_hull

def PolyArea(vertices, scaling_factor = 1):
    if isinstance(vertices, np.ndarray) is False:
        vertices = np.array(vertices)
    x,y = np.array(vertices[:, 0]) * scaling_factor, vertices[:, 1]  * scaling_factor
    #Shoelace formula
    return 0.5*np.abs(np.dot(x,np.roll(y,1))-np.dot(y,np.roll(x,1)))

def PolyPerimeter(vertices):
    if isinstance(vertices, np.ndarray) is False:
        vertices = np.array(vertices)
    shifted_vertices = np.roll(vertices, shift=-1, axis=0)  # Shift vertices for edge pairing
    # Calculate edge lengths per vertex and sum them
    return np.sum(np.linalg.norm(shifted_vertices - vertices, axis=1))

def contour_metrics(arr_2d):
    """
    Calculate various metrics for a 2D contour represented as a Cartesian grid.

    Parameters
    ----------
    arr_2d : ndarray, shape (N, 2)
        An array containing the 2D coordinates of the contour points.

    Returns
    -------
    num_verteces : int
        The number of vertices in the contour.
    vertex_angles : ndarray, shape (N,)
        An array containing the interior angles at each vertex in radians.
    vertex_points : ndarray, shape (N, 2)
        An array containing the 2D coordinates of the contour vertices.
    notch_bool : ndarray, shape (N,)
        A boolean array indicating whether each vertex forms a notch (angle > pi).
    num_notches : int
        The total number of notches in the contour.
    area_contour : float
        The area enclosed by the contour.
    perimeter_contour : float
        The perimeter of the contour.

    Notes
    -----
    This function calculates various metrics for a 2D contour, including the number of vertices,
    interior angles, notch information, area, and perimeter. If there are less than 3 points in the
    contour, it returns NaN values for all metrics.

    Examples
    --------
    >>> arr_2d = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])
    >>> contour_metrics(arr_2d)
    (4, array([1.57079633, 1.57079633, 1.57079633, 1.57079633]), array([[0, 0],
           [1, 0],
           [1, 1],
           [0, 1]]), array([False, False, False, False]), 0, 1.0, 4.0)
    """
    if arr_2d.dtype == 'O': # if an object snuck through 
        arr_2d = arr_2d.astype("float")
    flip_bool = 0
    _vertex_points =  get_vertex_points(arr_2d)
    try:
        if rotation_direction(arr_2d) == -1:
            flip_bool = 1
            arr_2d = np.flip(arr_2d, axis = 1)
    except ValueError:
        warnings.warn("Not enough points (< 3) to generate metrics")
        return (np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan)
    _vertex_angles = calculate_interior_angles(arr_2d)        
    _notch_bool = _vertex_angles > np.pi
    _num_notches = _notch_bool.sum()
    _num_verteces = len(_vertex_points)
    _area_contour = PolyArea(arr_2d)
    _perimeter_contour = PolyPerimeter(arr_2d)
    return _num_verteces, _vertex_angles, _vertex_points, _notch_bool, _num_notches, _area_contour, _perimeter_contour

def complexity_metrics(arr_2d):
    """
    Calculate complexity metrics for a 2D contour represented as a Cartesian grid.

    Parameters
    ----------
    arr_2d : ndarray, shape (N, 2)
        An array containing the 2D coordinates of the contour points.

    Returns
    -------
    notches_norm : float
        The normalized number of notches in the contour.
    amplitude_poly : float
        The amplitude of complexity based on perimeter differences.
    frequency_poly : float
        The frequency of complexity based on the normalized number of notches.
    convexity_poly : float
        The convexity of complexity based on area differences.
    complexity_poly : float
        The overall complexity metric combining amplitude, frequency, and convexity.

    Notes
    -----
    This function calculates complexity metrics for a 2D contour, including notches, amplitude,
    frequency, convexity, and an overall complexity measure.

    Examples
    --------
    >>> arr_2d = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])
    >>> complexity_metrics(arr_2d)
    (0.0, 0.0, 1.0, 0.0, 0.0)
    """
    if type(arr_2d) == list:
        arr_2d = np.array(arr_2d)
    if arr_2d.dtype == 'O': # if an object snuck through 
        arr_2d = arr_2d.astype("float")
    if arr_2d.size == 0:
        return np.nan, np.nan, np.nan, np.nan, np.nan
    # Get base metrics
    _num_vertices, _vertex_angles, _vertex_points, _notch_bool, _num_notches, _area_contour, _perimeter_contour = contour_metrics(arr_2d)
    if np.isnan(_num_vertices) is True: # checking only the first but shoudl be fine 
        # If all is nan, don't bother computing the rest --> just give nans 
        return np.nan, np.nan, np.nan, np.nan, np.nan
    # Create a convex hull and derive area/perimeter for both contour and its convex hull
    _convex_hull = get_convex_hull(arr_2d)
    _area_convex_hull = PolyArea(_convex_hull)
    # _perimeter_contour = PolyPerimeter(arr_2d)
    _perimeter_convex_hull = PolyPerimeter(_convex_hull)
    # Derive complexity measures
    _nothces_norm = _num_notches / (_num_vertices - 3)
    _amplitude_poly = (_perimeter_contour - _perimeter_convex_hull) / _perimeter_contour
    _frequency_poly = 16*(_nothces_norm-0.5)**4 - 8*(_nothces_norm-0.5)**2 + 1
    _convexity_poly = (_area_convex_hull - _area_contour) / _area_convex_hull
    _complexity_poly = 0.8 * _amplitude_poly * _frequency_poly + 0.2 * _convexity_poly
    return _nothces_norm, _amplitude_poly, _frequency_poly, _convexity_poly, _complexity_poly

def measures_demo(arr_2d, vertex_num = -1):
    # cont = arr_2d
    num_verteces, vertex_angles, vertex_points, notch_bool, num_notches, _area_contour, _perimeter_contour = contour_metrics(arr_2d)
    nothces_norm, amplitude_poly, frequency_poly, convexity_poly, complexity_poly = complexity_metrics(arr_2d)
    plt.scatter(arr_2d[:, 0], arr_2d[:, 1])
    plt.scatter(arr_2d[1:, 0][notch_bool == 1], arr_2d[1:, 1][notch_bool == 1], c = "orange", label = "notches")
    plt.plot(arr_2d[:, 0], arr_2d[:, 1])
    plt.scatter(arr_2d[:, 0][0], arr_2d[:, 1][0], c ="red", marker ="v", label = "start point")
    if vertex_num != -1:
        point = vertex_num
        plt.scatter(vertex_points[point][:, 0], vertex_points[point][:, 1], facecolors='none',edgecolors=['green', 'limegreen', 'green'],s =100, lw=3, label = "curr_vertex")
    convex_hull = get_convex_hull(arr_2d)
    plt.plot(convex_hull[:, 0], convex_hull[:, 1], "--k", label = "convex_hull")
    plt.title(f"Complexity = {np.round(complexity_poly, 4)}")
    plt.gca().set_aspect('equal')
    plt.legend()

def _metrics_multicontour(list_of_list):
    metrics = []
    for i in list_of_list:
        complexity = complexity_metrics(i)[-1]
        metrics.append(complexity)
    if metrics == []:
        metrics = [np.nan]
    return np.array(metrics)

def _complexity_allcontours(contours_tup):
    roi_results = []
    for n, (i, j) in enumerate(zip(contours_tup[:, 0], contours_tup[:, 1])):
        metric_tup = [_metrics_multicontour(i), _metrics_multicontour(j)]
        roi_results.append(metric_tup)
    return roi_results

def complexity_weighted(contours_tup, contours_areas):
    final_complexity_metric = []
    for n, ((neg_comp, pos_comp), (neg_areas, pos_areas)) in enumerate(zip(_complexity_allcontours(contours_tup), contours_areas)):
        area_weighted_pos_comp = np.nan
        area_weighted_neg_comp = np.nan
        if np.all(neg_areas != np.nan) and np.all(neg_areas>0):
            area_weighted_neg_comp = np.average(neg_comp, weights = np.nan_to_num(neg_areas))
            # print(n, "before:", neg_comp, "after:", np.round(area_weighted_neg_comp, 4))
        if np.all(pos_areas != np.nan) and np.all(pos_areas>0):
            area_weighted_pos_comp = np.average(pos_comp, weights = np.nan_to_num(pos_areas))
            # print(n, "before:", pos_comp, "after:", np.round(area_weighted_pos_comp, 4))
        final_complexity_metric.append((area_weighted_neg_comp, area_weighted_pos_comp))
    return np.array(final_complexity_metric)